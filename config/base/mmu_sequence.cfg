########################################################################################################################
# 快乐兔子支持宏
#  自定义加载和卸载顺序
#
# 该文件是只读的
#
# 这些骨架宏定义了灯丝加载或卸载期间进行的所有回调。它们可以扩展为
# 用户命令添加（请参阅“mmu_macro_vars.cfg”）或可以用作完全自定义宏的模板。笔记
# SAVE/RESTORE_GCODE_STATE 包装模式是预防性的
#
# 这些宏的顺序如下（如果未定义，则跳过）：
#
# 卸载序列...
#   _MMU_PRE_UNLOAD             在开始卸载之前调用
#     'form_tip_macro'          用户定义的尖端成形宏
#   _MMU_POST_FORM_TIP          尖端形成后立即调用
#     (_MMU_UNLOAD_SEQUENCE)    高级：可选择基于“gcode_unload_sequence”进行调用
#   _MMU_POST_UNLOAD            卸载完成后调用
#
# 加载顺序...
#   _MMU_PRE_LOAD               在开始加载之前调用
#     (_MMU_LOAD_SEQUENCE)      高级：可选择基于“gcode_load_sequence”进行调用
#   _MMU_POST_LOAD              加载完成后调用
#
# 如果更换工具，卸载序列将紧随加载序列之后
#
# 关于内置 Happy Hare 功能的注意事项（因此您无需担心）：
# 1. Happy Hare 单独实现了工具更改（包括 EndlessSpool）上的 z-hop 移动和打印时的错误
#    使用“z_hop_height_toolchange”参数指定
# 2. 工具头将在恢复打印之前正确放置，尽管逻辑只期望
#    正确的 z_hop 高度，如果需要水平移动，速度会很慢
# 3. 尖端成型后压力提前将自动恢复
# 4. 换刀后 M220 和 M221 倍率将保留
# 5. 如果配置，Spoolman 将收到工具更换通知
# 6. 如果发生错误导致暂停，挤出机温度将被保存并在 MMU_UNLOCK 或恢复时恢复
#
# 利用基本回调通常足以进行自定义，但是如果您确实想做某事
# 不寻常的是，您可以通过在“mmu_parameters.cfg”中设置以下内容来启用 gcode 加载/卸载序列
#
#   'gcode_load_sequence: 1'
#   'gcode_unload_sequence: 1'
#
# 这是相当高级的，在开始之前你需要了解 Happy Hare 状态机
# 变化。阅读文档很重要
#


###########################################################################
# 共享工具头停放宏旨在将工具头定位在合适的位置
# 停车或清理区域
#   Z_HOP | float - 覆盖 z 跳默认值
#
[gcode_macro _MMU_PARK]
description: Park toolhead safely away from print

# -------------------------- 内部请勿触摸 -------------------------
variable_saved_xyz: 0, 0, 0
variable_saved_pos: False
variable_next_xy: 0, 0
variable_next_pos: False
variable_initial_park_z: 9999	# 在换刀开始时存储 z 高度
variable_min_lifted_z: 0	# 支持上升的“z 提升平面”以进行顺序打印
variable_toolchange_z: 0	# 存储当前计算的换刀平面

gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
    {% set park_z_hop = params.Z_HOP|default(vars.park_z_hop|default(1))|float %}
    {% set enable_park = vars.enable_park|default(true)|lower == 'true' %}
    {% set enable_park_runout = vars.enable_park_runout|default(true)|lower == 'true' %}
    {% set enable_park_standalone = vars.enable_park_standalone|default(true)|lower == 'true' %}
    {% set x, y = vars.park_xy|default([50,50])|map('float') %}
    {% set travel_speed = vars.travel_speed|default(200)|float * 60 %}
    {% set lift_speed = vars.lift_speed|default(15)|float * 60 %}
    {% set pos = printer.gcode_move.gcode_position %}
    {% set origin = printer.gcode_move.homing_origin %}
    {% set max = printer.toolhead.axis_maximum %}

    # starting_z 是计算换刀高度的高度
    {% set starting_z = [[saved_xyz[2] if saved_pos else pos.z, initial_park_z]|min, min_lifted_z]|max %}
    {% set toolchange_z = [starting_z + park_z_hop, max.z - origin.z]|min %}

    # 根据模式自定义操作的有用状态
    {% set runout = printer.mmu.runout %}
    {% set printing = printer.mmu.print_state == 'printing' %}

    SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=toolchange_z VALUE={toolchange_z}
    {% if (enable_park and printing and not runout) or (enable_park_runout and runout) or (enable_park_standalone and not printing) %}
        {% if not 'xy' in printer.toolhead.homed_axes %}
            RESPOND MSG="Cannot park because XY not homed"
        {% else %}
            G90						# 绝对
            {% if park_z_hop > 0 %}
                {% if not 'z' in printer.toolhead.homed_axes %}
                    RESPOND MSG="Skipping z_hop because Z not homed"
                {% else %}
                    {% if initial_park_z >= 9999 %}
                        SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=initial_park_z VALUE={starting_z}
                    {% endif %}
                    G1 Z{toolchange_z} F{lift_speed}	# 首先应用 Z 提升
                {% endif %}
            {% endif %}
            G1 X{x} Y{y} F{travel_speed}		# 移动到停车位置
        {% endif %}
    {% endif %}


###########################################################################
# 辅助宏：保存当前工具头位置
#
[gcode_macro _MMU_SAVE_POSITION]
description: Record to toolhead position for return later
gcode:
    {% set park_vars = printer['gcode_macro _MMU_PARK'] %}
    {% set pos = printer.gcode_move.gcode_position %}

    {% if not park_vars.saved_pos and 'xyz' in printer.toolhead.homed_axes %}
        SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=saved_xyz VALUE="{pos.x}, {pos.y}, {pos.z}"
        SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=saved_pos VALUE={True}
    {% endif %}


###########################################################################
# 辅助宏：恢复以前保存的位置
#
[gcode_macro _MMU_RESTORE_POSITION]
description: Restore saved toolhead position
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
    {% set park_vars = printer['gcode_macro _MMU_PARK'] %}
    {% set x,y,z = park_vars.saved_xyz|map('float') %}
    {% set nx,ny = park_vars.next_xy|map('float') %}
    {% set travel_speed = vars.travel_speed|default(200)|float * 60 %}
    {% set lift_speed = vars.lift_speed|default(15)|float * 60 %}
    {% set restore_xy_pos = vars.restore_xy_pos|default('last') %}
    {% set printing = printer.mmu.print_state == 'printing' %}

    G90							# 绝对
    {% if park_vars.saved_pos and 'z' in printer.toolhead.homed_axes %}
        G1 Z{park_vars.toolchange_z} F{lift_speed}	# 确保处于换刀高度以避免碰撞
    {% endif %}
    {% if park_vars.next_pos and restore_xy_pos == 'next' %}
        G1 X{nx} Y{ny} F{travel_speed}			# 将 X,Y 恢复到下一个位置
    {% elif park_vars.saved_pos and (restore_xy_pos == 'last' or not printing) %} # 我们或切片机是否恢复位置
        G1 X{x} Y{y} F{travel_speed}			# 将 X、Y 恢复至上次位置
    {% endif %}
    {% if park_vars.saved_pos and 'z' in printer.toolhead.homed_axes %}
        G1 Z{z} F{lift_speed}				# 恢复原来的Z高度
    {% endif %}
    _MMU_CLEAR_POSITION


###########################################################################
# 辅助宏：清除以前保存的位置
#
[gcode_macro _MMU_CLEAR_POSITION]
description: Clear previously recorded toolhead position and park z_hop
gcode:
    SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=saved_pos VALUE={False}
    SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=next_pos VALUE={False}
    SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=initial_park_z VALUE=9999


###########################################################################
# 辅助宏：记录最大工具头高度
# 设计为从切片器层调用更改的逻辑
#
[gcode_macro _MMU_UPDATE_HEIGHT]
description: Record maximum toolhead height for z-hop base
gcode:
    {% set height = params.HEIGHT|default(0)|float %}
    {% set park_vars = printer['gcode_macro _MMU_PARK'] %}
    {% set max_z = [park_vars.min_lifted_z, printer.gcode_move.gcode_position.z, height]|max %}

    SET_GCODE_VARIABLE MACRO=_MMU_PARK VARIABLE=min_lifted_z VALUE={max_z}


###########################################################################
# 辅助宏：恢复以前保存的位置
#
[gcode_macro _MMU_AUTO_HOME]
description: Convenience auto homing primarily for testing
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
    {% set auto_home = vars.auto_home|default(true)|lower == 'true' %}

    {% if not 'xy' in printer.toolhead.homed_axes and auto_home %}
        RESPOND MSG="Automatically homing XY"
        G28 X Y
    {% endif %}


###########################################################################
# 这发生在换刀时卸载灯丝之前
#
[gcode_macro _MMU_PRE_UNLOAD]
description: Optional pre unload routine for filament change
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
    {% set park_after_form_tip = vars.park_after_form_tip|default(false)|lower == 'true' %}

    SAVE_GCODE_STATE NAME=MMU_PRE_UNLOAD_state

    _MMU_AUTO_HOME
    _MMU_SAVE_POSITION
    {% if not park_after_form_tip %}
        _MMU_PARK
    {% endif %}

    {vars.user_pre_unload_extension|default("")}

    RESTORE_GCODE_STATE NAME=MMU_PRE_UNLOAD_state


###########################################################################
# 这会在尖端成型或切割程序之后立即发生
#
[gcode_macro _MMU_POST_FORM_TIP]
description: Optional post tip forming/cutting routing
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
    {% set park_after_form_tip = vars.park_after_form_tip|default(false)|lower == 'true' %}

    SAVE_GCODE_STATE NAME=MMU_POST_FORM_TIP_state

    {% if park_after_form_tip %}
        _MMU_PARK
    {% endif %}

    RESTORE_GCODE_STATE NAME=MMU_POST_FORM_TIP_state


###########################################################################
# 在换刀时卸载灯丝后立即发生这种情况
#
[gcode_macro _MMU_POST_UNLOAD]
description: Optional post unload routine for filament change
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}

    SAVE_GCODE_STATE NAME=MMU_POST_UNLOAD_state

    # 这是注入逻辑的好地方，例如执行提示
    # 当刀具位于MMU时进行切割，从而准备卸载
    # 下次使用的胶片
    {vars.user_post_unload_extension|default("")}

    RESTORE_GCODE_STATE NAME=MMU_POST_UNLOAD_state


###########################################################################
# 这发生在换刀时开始加载顺序之前
#
[gcode_macro _MMU_PRE_LOAD]
description: Optional pre load routine for filament change
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}

    SAVE_GCODE_STATE NAME=MMU_PRE_LOAD_state

    # 我们在这里重复停车逻辑，以便加载序列可以运行
    # 独立于卸载顺序
    _MMU_AUTO_HOME
    _MMU_SAVE_POSITION
    _MMU_PARK

    {vars.user_pre_load_extension|default("")}

    RESTORE_GCODE_STATE NAME=MMU_PRE_LOAD_state


###########################################################################
# 在工具更换上加载新灯丝后会发生这种情况
#
[gcode_macro _MMU_POST_LOAD]
description: Optional post load routine for filament change
gcode:
    {% set vars = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
    {% set timelapse = vars.timelapse|default(false)|lower == 'true' %}
    {% set mmu_paused = printer.mmu.is_locked %}

    SAVE_GCODE_STATE NAME=MMU_POST_LOAD_state

    {% if timelapse %}
        TIMELAPSE_TAKE_FRAME
    {% endif %}

    # 实现自定义清除逻辑和/或喷嘴清洁的好地方
    # 返回 print/wipetower 之前
    {vars.user_post_load_extension|default("")}

    {% if not mmu_paused %}
        _MMU_RESTORE_POSITION
    {% endif %}

    RESTORE_GCODE_STATE NAME=MMU_POST_LOAD_state


###########################################################################
#   高级 高级 高级 高级 高级 高级
# 用户可修改装载和卸载顺序
#
# 默认情况下Happy Hare会调用内部逻辑来处理加载和卸载
# 序列。要启用用户定义序列的调用，您必须添加
# 以下为您的mmu_parameters.cfg
#
# gcode_load_sequence: 1	# G代码加载顺序 1=启用，0=内部逻辑（默认）
# gcode_unload_sequence: 1	# Gcode卸载顺序，1=启用，0=内部逻辑（默认）
#
# 此参考示例加载顺序完全模仿内部加载顺序。它使用
# 高级“模块化”运动，全部由中定义的参数控制
# mmu_parameters.cfg 并自动保持内部灯丝位置状态最新。
# 切换到这些宏不应改变行为，并且可以作为
# 你的定制
#
# 状态机：
# 如果您的实验超出了此处所示的基本示例，您将需要了解
# 灯丝位置的可能状态。这和暴露的状态是一样的
# 作为 `printer.mmu.filament_pos` 打印机变量。该内部状态必须是
# 保持最新状态，并且需要在您完成任务时直接设置
# 自定义移动顺序。此时状态机是不可扩展的。
#
#        FILAMENT_POS_UNKNOWN = -1
#  L  ^  FILAMENT_POS_UNLOADED = 0
#  O  |  FILAMENT_POS_HOMED_GATE = 1     # 如果安装了门传感器
#  A  |  FILAMENT_POS_START_BOWDEN = 2
#  D  |  FILAMENT_POS_IN_BOWDEN = 3
#        FILAMENT_POS_END_BOWDEN = 4
#  |  U  FILAMENT_POS_HOMED_ENTRY = 5    # 如果安装了挤出机（入口）传感器
#  |  N  FILAMENT_POS_HOMED_EXTRUDER = 6
#  |  L  FILAMENT_POS_PAST_EXTRUDER = 7
#  |  O  FILAMENT_POS_HOMED_TS = 8       # 如果安装了工具头传感器
#  |  A  FILAMENT_POS_IN_EXTRUDER = 9    # AKA 细丝经过工具头传感器
#  v  D  FILAMENT_POS_LOADED = 10        # AKA 细丝安装在喷嘴上
#
# Final notes:
# 1) 您需要尊重传递到宏中的上下文，例如
#     想要移动的“长度”，因为可以调用它来进行测试加载
# 2) 可以在灯丝处于任何位置（状态）时调用卸载宏
#     你需要处理任何起点。默认参考
#     作为一个很好的指南
#
[gcode_macro _MMU_LOAD_SEQUENCE]
description: Called when MMU is asked to load filament
gcode:
    {% set filament_pos = params.FILAMENT_POS|float %}
    {% set length = params.LENGTH|float %}
    {% set full = params.FULL|int %}
    {% set home_extruder = params.HOME_EXTRUDER|int %}
    {% set skip_extruder = params.SKIP_EXTRUDER|int %}
    {% set extruder_only = params.EXTRUDER_ONLY|int %}

    {% if extruder_only %}
        _MMU_STEP_LOAD_TOOLHEAD EXTRUDER_ONLY=1

    {% elif filament_pos >= 7 %}                        # FILAMENT_POS_PAST_EXTRUDER
        {action_raise_error("Can't load - already in extruder!")}

    {% else %}
        {% if filament_pos <= 0 %}                      # FILAMENT_POS_UNLOADED
            _MMU_STEP_LOAD_GATE
        {% endif %}

        {% if filament_pos < 4 %}                       # FILAMENT_POS_END_BOWDEN
            _MMU_STEP_LOAD_BOWDEN LENGTH={length}
        {% endif %}

        {% if filament_pos < 6 and home_extruder %}     # FILAMENT_POS_HOMED_EXTRUDER
            _MMU_STEP_HOME_EXTRUDER
        {% endif %}

        {% if not skip_extruder %}                      # FILAMENT_POS_PAST_EXTRUDER
            _MMU_STEP_LOAD_TOOLHEAD
        {% endif %}

    {% endif %}

[gcode_macro _MMU_UNLOAD_SEQUENCE]
description: Called when MMU is asked to unload filament
gcode:
    {% set filament_pos = params.FILAMENT_POS|float %}
    {% set length = params.LENGTH|float %}
    {% set extruder_only = params.EXTRUDER_ONLY|int %}
    {% set park_pos = params.PARK_POS|float %}

    {% if extruder_only %}
        {% if filament_pos >= 7 %}                      # FILAMENT_POS_PAST_EXTRUDER
            _MMU_STEP_UNLOAD_TOOLHEAD EXTRUDER_ONLY=1 PARK_POS={park_pos}
        {% else %}
            {action_raise_error("Can't unload extruder - already unloaded!")}
        {% endif %}

    {% elif filament_pos == 0 %}
        {action_raise_error("Can't unload - already unloaded!")}

    {% else %}
        {% if filament_pos >= 7 %}                      # FILAMENT_POS_PAST_EXTRUDER
            # 退出挤出机，快速卸载 Bowden，然后慢速卸载编码器
            _MMU_STEP_UNLOAD_TOOLHEAD PARK_POS={park_pos}
        {% endif %}

        {% if filament_pos >= 4 %}                      # FILAMENT_POS_END_BOWDEN
            # 快速卸载 Bowden，然后慢速卸载编码器
            _MMU_STEP_UNLOAD_BOWDEN FULL=1
            _MMU_STEP_UNLOAD_GATE

        {% elif filament_pos >= 2 %}                    # FILAMENT_POS_START_BOWDEN
            # 必须缓慢卸载，因为我们不知道我们在鲍登的确切位置
            _MMU_STEP_UNLOAD_GATE FULL=1
        {% endif %}

    {% endif %}

#
# 下面是一些替代宏的示例
#
# 1. 该加载示例利用内置模块将灯丝加载到末端
# 鲍登管的。然后将灯丝放置到工具头传感器 (mmu_toolhead)
# 使用同步齿轮和挤出机运动。状态已更新以反映这一点
# 新的位置。然后，它执行 62 毫米的同步步进移动，以推进
# 灯丝到喷嘴
#
#[gcode_macro _MMU_LOAD_SEQUENCE]
#description: 当 MMU 被要求加载灯丝时调用
#gcode:
#    {% set filament_pos = params.FILAMENT_POS|float %}
#    {% set length = params.LENGTH|float %}
#    {% set skip_extruder = params.SKIP_EXTRUDER|int %}
#    {% set extruder_only = params.EXTRUDER_ONLY|int %}
#
#    {% if extruder_only %}
#        _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_toolhead MOVE=50 MOTOR=extruder
#        _MMU_STEP_SET_FILAMENT STATE=8		# FILAMENT_POS_HOMED_TS
#        _MMU_STEP_MOVE MOVE=62 MOTOR=extruder
#        _MMU_STEP_SET_FILAMENT STATE=10	# FILAMENT_POS_LOADED
#    {% else %}
#        _MMU_STEP_LOAD_GATE
#        _MMU_STEP_LOAD_BOWDEN LENGTH={length}
#        {% if full and not skip_extruder %}
#            _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_toolhead MOVE=50 MOTOR=gear+extruder
#            _MMU_STEP_SET_FILAMENT STATE=8	# FILAMENT_POS_HOMED_TS
#            _MMU_STEP_MOVE MOVE=62 MOTOR=gear+extruder
#            _MMU_STEP_SET_FILAMENT STATE=10	# FILAMENT_POS_LOADED
#        {% endif %}
#    {% endif %}
#
#
# 2. 这个非常简化的加载示例以类似的方式开始加载到结束
# 校准鲍登。然后它简单地归位到喷嘴（使用挤出机上的 TMC 支架）
# 步进器！）带有同步挤出机+齿轮步进器。这需要`mmu_ext_touch`
# endstop 是为挤出机步进器定义的终点之一
#
#[gcode_macro _MMU_LOAD_SEQUENCE]
#description: 当 MMU 被要求加载灯丝时调用
#gcode:
#    {% set length = params.LENGTH|float %}
#    {% set full = params.FULL|int %}
#    {% set skip_extruder = params.SKIP_EXTRUDER|int %}
#    {% set extruder_only = params.EXTRUDER_ONLY|int %}
#
#    {% if extruder_only %}
#        _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_ext_touch MOVE=100 MOTOR=extruder
#        _MMU_STEP_SET_FILAMENT STATE=10	# FILAMENT_POS_LOADED
#    {% else %}
#        _MMU_STEP_LOAD_GATE
#        _MMU_STEP_LOAD_BOWDEN LENGTH={length}
#        {% if full and not skip_extruder %}
#            _MMU_STEP_HOMING_MOVE ENDSTOP=mmu_ext_touch MOVE=100 MOTOR=extruder+gear
#            _MMU_STEP_SET_FILAMENT STATE=10	# FILAMENT_POS_LOADED
#        {% endif %}
#    {% endif %}

